
# Firestone by teamDYB

An implementation of a Hearthstone back-end covering sprints 1-3 in DD2487 Large-Scale Software Development, autumn 2018

## Overview

We have kept the basic structure of a-light-in-the-darkness:

* Definitions for cards, minions and heroes live in *src/firestone/definition* and we use the original `firestone.definitions` and `firestone.definitions-loader`
* "Constructors" (e.g `create-game`, `create-hero` ...) live in *src/firestone/construct*
* Most "state transitions" (e.g `freeze-entity`, `remove-secrets`) live in *src/firestone/core*
* The server (*src/firestone/server*), edn-api (*src/firestone/edn-api*), instrumentation (*src/firestone/instrumentation*) and mapper (*src/firestone/mapper*) should present very few surprises.
* The spec (*src/firestone/spec*) is unchanged.
* Tests for individual functions are part of each function definition.

We have built upon this structure as follows:

* The user-facing API (e.g `draw-card`, `play-spell-card`) lives in *src/firestone/api*
* Most "getters" (e.g `get-health`, `get-number-of-cards-in-deck`) live in *src/firestone/info* (including those supplied by a-light-in-the-darkness in *src/firestone/construct*  (e.g `get-minions`))
* State transitions that damage and/or destroy entities (e.g `damage-entity`) live in *src/firestone/damage-entity*
* State transitions associated with mana (e.g `spend-mana`) live in *src/firestone/mana*
* State transitions associated with events (e.g `do-battlecry`, `fire-on-damage-event`) live in *src/firestone/events*
* Tests for game entities live in *src/firestone/definition/(hero-power|minion|spell)-tests*

## Details (ids, randomness and seed, events and states etc)
### Entity IDs
* Entity IDs are strings containing only digits (integers cast to string).
* IDs are generated in *construct*, e.g *construct/add-card-to-hand, construct/add-secret-to-board*.
* Card IDs are copied over to minions when minion cards are played.

### Randomness
* We use *ysera.random* directly, e.g *ysera.random/random-nth*
* We store a key *:seed* in our master state map.
* We manually update the seed in each instance where randomness is used (e.g Sneed's deathrattle)

### Special effects, buffs and event listeners
* +Spell damage is stored as zero or more maps in the minion key *:auras*:

        "Malygos" {:name "Malygos",
                   :attack 4,
                   ...
                   :auras [{:spell-damage 5}],

* Buffs are stored as zero or more individual maps `{:name x :attack-buff y :max-health-buff z}` under the minion key path `[:states :buffs]`

        "Malygos" {:name "Malygos",
                   :attack 4,
                   ...
                   :states {:buffs [{:name "Competitive Spirit"
                                      :attack-buff 1
                                      :max-health-buff 1}]},

* Event listeners are stored as zero or more maps `{:effect-source x, :effect-key y}` under keys named according to the event (e.g `:on-end-of-turn`), which are in turn stored under the minion key path `[:states :effect]`. Each event listener map acts as a lookup into the card definitions where the actual event handler function is to be found. The lookup is performed by fetching the key indicated by *:effect-key* from the card definition having the name indicated by *:effect-source*.

        "Malygos" {:name "Malygos",
                   :attack 4,
                   ...
                   :states {:effect {:on-end-of-turn {:effect-source "Malygos"
                                                      :effect-key :some-event-handler}}},
                   :some-event-handler (fn [state args] produce new state)

## Running tests

We run tests using `lein test`

## Additional Tools

### Firestone server shortcut
We have an additional Leiningen task for starting the firestone server: `lein server`

### Autodoc
We have a tool called 'autodoc' that can generate a handy function index from the current codebase.
The tool lives in */autodoc.clj* and the intended way of running it is thru Leiningen using the custom
task `lein doc`. Running this task with no further arguments will print a short usage guide. To actually
use the tool you will run `lein doc TARGET` where the targets are:

| Target | Description |
| :---   | :---        |
| `bare` | Print a bare plain text function index without docstrings, suitable for e.g piping to `grep`|
| `index` | Print a plain text function index with docstrings and more spacing making it easier to read.|
| `html` | Print an HTML document with embedded Javascript that contains the function index with docstrings along with a dynamic search/filter function. We recommend you send the output directly to a file, e.g `lein doc html > doc.html`|
| `server` | Start a server that serves the document generated by the 'html' mode, properly reloading all code on page refresh.|
