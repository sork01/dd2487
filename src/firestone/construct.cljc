(ns firestone.construct
  (:require [clojure.test :refer [function?]]
            [ysera.test :refer [is is-not is= error?]]
            [clojure.pprint :refer [pprint]]
            [firestone.spec :as fspec]
            [clojure.spec.alpha :as spec]
            [firestone.definitions :refer [get-definition]]))

(defn- generate-id
  "Generates an id and returns a tuple with the new state and the generated id."
  {:test (fn [] (is= (generate-id {:counter-id 6}) [{:counter-id 7} 6]))}
  [state]
  [(update state :counter-id inc) (:counter-id state)])

(defn- generate-play-order
  "Generates next play-order id and returns a tuple with the new state and the generated id."
  {:test (fn []
           (is= (generate-play-order {:counter-play-order 6})
                [{:counter-play-order 7} 6]))}
  [state]
  [(update state :counter-play-order inc) (:counter-play-order state)])

(declare add-card-to-hand)
(declare create-game)
(declare is-player?)
(declare get-secrets)
(declare get-entity)
(declare get-hand)

(defn create-hero
  "Creates a hero from its definition by the given hero name. The additional key-values will override the default values."
  {:test (fn []
           (is= (create-hero "Jaina Proudmoore")
                {:name "Jaina Proudmoore",
                 :entity-type :hero,
                 :health 30,
                 :max-health 30,
                 :hero-power "Fireblast",
                 :times-hero-power-used 0,
                 :frozen false})
           (is= (create-hero "Jaina Proudmoore" :health 10)
                {:name "Jaina Proudmoore",
                 :entity-type :hero,
                 :health 10,
                 :max-health 30,
                 :hero-power "Fireblast",
                 :times-hero-power-used 0,
                 :frozen false}))}
  [name & kvs]
  (let [hero-def (get-definition name)]
    (let [hero {:name name,
                :entity-type :hero,
                :health (:health hero-def),
                :max-health (:health hero-def),
                :hero-power (:hero-power hero-def),
                :times-hero-power-used 0,
                :frozen false}]
      (if (empty? kvs) hero (apply assoc hero kvs)))))

(defn create-card
  "Creates a card from its definition by the given card name. The additional key-values will override the default values."
  {:test (fn []
           (is= (-> (create-card "Arcane Golem" :id "c1")
                    (:name))
                "Arcane Golem")
           ;(pprint (get-definition "Frothing Berserker"))
           (is= (create-card "Frothing Berserker" :id "i")
                {:id "i",
                 :attack 2,
                 :health 4,
                 :mana-cost 3,
                 :type :card,
                 :states {:effect {:on-damage [{:effect-source
                                                  "Frothing Berserker",
                                                :effect-key :on-damage}]}},
                 :name "Frothing Berserker"}))}
  [name & kvs]
  (let [card-def (get-definition name)]
    (as-> {:attack (:attack card-def),
           :health (:health card-def),
           :states (get card-def :states {}),
           :mana-cost (:mana-cost card-def),
           :type :card,
           :name (:name card-def)} $
      (if (empty? kvs) $ (apply assoc $ kvs)))))

(defn create-secret
  "Creates a secret from a card or by a name. Additional key-values will override the default values. Not that these are outside the state and thus cannot have an autogenerated ID."
  {:test (fn []
           (is= (-> (create-secret (create-card "Snake Trap"))
                    (:entity-type))
                "secret"))}
  [card-or-name & kvs]
  (let [card (if (string? card-or-name) (create-card card-or-name) card-or-name)
        card-def (get-definition (:name card))
        secret {:entity-type "secret",
                :name (:name card),
                :states (or (:states card-def) {}),
                :play-order 0}]
    (as-> (if (contains? card :id) (assoc secret :id (:id card)) secret) $
      (if (empty? kvs) $ (apply assoc $ kvs)))))


(defn create-minion
  "Creates a minion from a card or by a name. The additional key-values will override the default values. Not that these are outside the state and thus cannot have an autogenerated ID."
  {:test (fn []
           (is= (-> (create-minion (create-card "Imp") :id "x")
                    (:id))
                "x")
           (is= (create-minion (create-card "Imp" :id "i")
                               :attacks-performed-this-turn
                               1)
                {:attacks-performed-this-turn 1,
                 :entity-type "minion",
                 :attack 1,
                 :original-attack 1,
                 :health 1,
                 :original-health 1,
                 :max-health 1,
                 :states {},
                 :name "Imp",
                 :id "i",
                 :frozen false,
                 :play-order 0}))}
  [card-or-name & kvs]
  (let [card (if (string? card-or-name) (create-card card-or-name) card-or-name)
        card-def (get-definition (:name card))
        minion {:entity-type "minion",
                :name (:name card),
                :attack (:attack card),
                :original-attack (:attack card-def),
                :health (:health card),
                :original-health (:health card-def),
                :max-health (:health card),
                :states (or (:states card) {}),
                :attacks-performed-this-turn 0,
                :frozen false,
                :play-order 0}]
    (as-> (if (contains? card :id) (assoc minion :id (:id card)) minion) $
      (if (contains? card-def :auras) (assoc $ :auras (:auras card-def)) $)
      (if (empty? kvs) $ (apply assoc $ kvs)))))


(defn create-empty-state
  "Creates an empty state with the given heroes."
  {:test (fn []
           (is= (create-empty-state [(create-hero "Jaina Proudmoore")
                                     (create-hero "Jaina Proudmoore")])
                (create-empty-state))
           ; In a new game, no cards should have been overdrawn for p1 or p2
           (is= (-> (create-empty-state)
                    (:players)
                    (get "p1")
                    (:cards-overdrawn))
                0)
           (is= (-> (create-empty-state)
                    (:players)
                    (get "p2")
                    (:cards-overdrawn))
                0)
           (is= (create-empty-state [(create-hero "Jaina Proudmoore")
                                     (create-hero "Jaina Proudmoore")])
                {:player-id-in-turn "p1",
                 :players {"p1" {:id "p1",
                                 :deck [],
                                 :hand [],
                                 :minions [],
                                 :secrets [],
                                 :cards-overdrawn 0,
                                 :mana 10,
                                 :max-mana 10,
                                 :hero {:name "Jaina Proudmoore",
                                        :id "h1",
                                        :health 30,
                                        :max-health 30,
                                        :entity-type :hero,
                                        :hero-power "Fireblast",
                                        :times-hero-power-used 0,
                                        :frozen false}},
                           "p2" {:id "p2",
                                 :deck [],
                                 :hand [],
                                 :minions [],
                                 :secrets [],
                                 :cards-overdrawn 0,
                                 :mana 10,
                                 :max-mana 10,
                                 :hero {:name "Jaina Proudmoore",
                                        :id "h2",
                                        :health 30,
                                        :max-health 30,
                                        :entity-type :hero,
                                        :hero-power "Fireblast",
                                        :times-hero-power-used 0,
                                        :frozen false}}},
                 :counter-id 1,
                 :counter-play-order 1,
                 :minion-ids-summoned-this-turn [],
                 :spells-cast-this-turn [],
                 :seed 314159265}))}
  ([heroes]
   ; Creates Jaina Proudmoore heroes if heroes are missing.
   (let [heroes (->> (concat heroes
                             [(create-hero "Jaina Proudmoore")
                              (create-hero "Jaina Proudmoore")])
                     (take 2))]
     {:player-id-in-turn "p1",
      :players (->>
                 heroes
                 (map-indexed (fn [index hero]
                                {:id (str "p" (inc index)),
                                 :deck [],
                                 :hand [],
                                 :minions [],
                                 :secrets [],
                                 :cards-overdrawn 0,
                                 :mana 10,
                                 :max-mana 10,
                                 :hero (assoc hero :id (str "h" (inc index)))}))
                 (reduce (fn [a v] (assoc a (:id v) v)) {})),
      :counter-id 1,
      :counter-play-order 1,
      :minion-ids-summoned-this-turn [],
      :spells-cast-this-turn [],
      :seed 314159265}))
  ([] (create-empty-state [])))

(defn get-player-id-in-turn
  {:test (fn []
           (is= (-> (create-empty-state)
                    (get-player-id-in-turn))
                "p1"))}
  [state]
  (:player-id-in-turn state))

(defn get-player
  "Returns the player with the given id."
  {:test (fn []
           (is= (-> (create-empty-state)
                    (get-player "p1")
                    (:id))
                "p1"))}
  [state player-id]
  (get-in state [:players player-id]))

(defn get-minions
  "Returns the minions on the board for the given player-id or for both players."
  {:test (fn []
           (is= (-> (create-empty-state)
                    (get-minions "p1"))
                [])
           (is= (-> (create-empty-state)
                    (get-minions))
                []))}
  ([state player-id] (:minions (get-player state player-id)))
  ([state]
   {:pre [(map? state)]}
   (->> (:players state)
        (vals)
        (map :minions)
        (apply concat))))



(defn add-minion-to-board
  "Adds a minion with a fresh generated id and a given position to a player's minions and updates the other minions' positions."
  {:test
     (fn []
       ; Adding a minion to an empty board
       (is= (as-> (create-empty-state) $
              (add-minion-to-board $
                                   {:player-id "p1",
                                    :minion (create-minion "Imp" :id "i"),
                                    :position 0})
              (get-minions $ "p1")
              (map (fn [m] {:id (:id m), :name (:name m)}) $))
            [{:id "i", :name "Imp"}])
       ; Adding a minion and update positions
       (let [state
               (-> (create-empty-state)
                   (add-minion-to-board {:player-id "p1",
                                         :minion (create-minion "Imp" :id "i1"),
                                         :position 0})
                   (add-minion-to-board {:player-id "p1",
                                         :minion (create-minion "Imp" :id "i2"),
                                         :position 0})
                   (add-minion-to-board {:player-id "p1",
                                         :minion (create-minion "Imp" :id "i3"),
                                         :position 1})
                   (get-minions "p1"))]
         (is= (map :id state) ["i1" "i2" "i3"])
         (is= (map :position state) [2 0 1]))
       ; Generating an id for the new minion
       (let [state (-> (create-empty-state)
                       (add-minion-to-board {:player-id "p1",
                                             :minion (create-minion "Imp"),
                                             :position 0}))]
         (is= (-> (get-minions state "p1")
                  (first)
                  (:id))
              "1")
         (is= (:counter-id state) 2))
       ; Adding a minion WITHOUT a nonzero play-order should set a nonzero
       ; play-order
       (is= (as-> (create-empty-state) $
              (add-minion-to-board $
                                   {:player-id "p1",
                                    :minion (create-minion "Imp" :id "i"),
                                    :position 0})
              (first (get-minions $ "p1"))
              (:play-order $))
            1)
       ; Adding a minion WITH a nonzero play-order should use the existing
       ; play-order
       (is= (as-> (create-empty-state) $
              (add-minion-to-board
                $
                {:player-id "p1",
                 :minion (create-minion "Imp" :id "i" :play-order 123),
                 :position 0})
              (first (get-minions $ "p1"))
              (:play-order $))
            123))}
  [state
   {player-id :player-id,
    minion :minion,
    position :position,
    target-id :target-id}]
  {:pre [(map? state) (string? player-id) (map? minion) (number? position)]}
  (if (= 7 (count (get-minions state player-id)))
    ; If is already 7 minions on the board, discard the new minion
    state
    (let [[state id]
            (if (contains? minion :id) [state (:id minion)] (generate-id state))
          [state play-order] (if (not= (:play-order minion) 0)
                               [state (:play-order minion)]
                               (generate-play-order state))]
      (-> (update-in state
                     [:players player-id :minions]
                     (fn [minions]
                       (conj (->> minions
                                  (mapv (fn [m]
                                          (if (< (:position m) position)
                                            m
                                            (update m :position inc)))))
                             (assoc minion
                               :position position
                               :owner-id player-id
                               :id (str id)
                               :play-order play-order))))
          (update :minion-ids-summoned-this-turn #(conj % (str id)))))))

(defn add-secret-to-board
  "Add secret to board. Give it an id"
  {:test (fn []
           ; Test ID generation
           (is= (as-> (create-game) $
                  (add-secret-to-board $ "p1" (create-card "Snake Trap"))
                  (get-in $ [:players "p1" :secrets 0 :id]))
                "1")
           ; Test play-order generation
           (is= (as-> (create-game) $
                  (add-secret-to-board $ "p1" (create-secret "Snake Trap"))
                  (get-in $ [:players "p1" :secrets 0 :play-order]))
                1)
           (is=
             (as-> (create-game) $
               (add-secret-to-board $
                                    "p1"
                                    (create-secret "Snake Trap" :play-order 84))
               (get-in $ [:players "p1" :secrets 0 :play-order]))
             84))}
  [state player-id card-or-secret]
  {:pre [(is-player? state player-id) (string? player-id) (map? state)
         (map? card-or-secret)]}
  ; Check if an ID was given, otherwise, generate one
  (let [[state card-or-secret] (if (contains? card-or-secret :id)
                                 [state card-or-secret]
                                 (let [[state id] (generate-id state)]
                                   [state (assoc card-or-secret :id (str id))]))
        [state play-order] (if (and (contains? card-or-secret :play-order)
                                    (not= (:play-order card-or-secret) 0))
                             [state (:play-order card-or-secret)]
                             (generate-play-order state))]
    (as-> (assoc card-or-secret :owner-id player-id) $
      (assoc $ :play-order play-order)
      (update-in state [:players player-id :secrets] #(conj %1 $)))))

(defn create-game
  ; TODO make (create-game [{:mana 4 :max-mana 10}]) work
  "Creates a game with the given deck, hand, minions (placed on the board), and heroes. Sets :minion-ids-summoned-this-turn to empty To set the random seed, pass :seed n as part of the 'kvs' argument"
  {:test
     (fn []
       (is= (create-game) (create-empty-state))
       (is= (create-game [{:hero (create-hero "Anduin Wrynn")}])
            (create-game [{:hero "Anduin Wrynn"}]))
       (is= (-> (create-game [{:hand [(create-card "Imp")]}])
                (get-in [:players "p1" :hand 0 :name]))
            "Imp")
       (is= (-> (create-game [{} {:hand [(create-card "Imp")]}])
                (get-in [:players "p2" :hand 0 :name]))
            "Imp")
       (is= (-> (create-game [{:deck [(create-card "Defender")]}])
                (get-in [:players "p1" :deck 0 :name]))
            "Defender")
       (is= (-> (create-game [{:deck [(create-card "Defender")]}])
                (get-in [:players "p1" :deck 0 :name]))
            "Defender")
       ; Test if id is preserved in deck
       (is= (-> (create-game [{} {:deck [(create-card "Defender" :id "z100")]}])
                (get-in [:players "p2" :deck 0 :id]))
            "z100")
       ; Test if id is preserved in hand
       (is= (-> (create-game [{} {:hand [(create-card "Defender" :id "z100")]}])
                (get-in [:players "p2" :hand 0 :id]))
            "z100")
       ; Test if id is generated for hand
       (is= (-> (create-game [{} {:hand [(create-card "Defender")]}])
                (get-in [:players "p2" :hand 0 :id]))
            "1")
       ; Test multiple minions added to hand
       (as-> (create-game [{:hand [(create-card "Defender")
                                   (create-card "Imp")]}]) $
         (get-in $ [:players "p1" :hand])
         (do (is= (count $) 2)
             (is= (:id (first $)) "1")
             (is= (:id (last $)) "2")))
       (is= (create-game
              [{:mana 1, :max-mana 1, :minions [(create-minion "Imp" :id "m1")]}
               {:mana 5,
                :max-mana 10,
                :hero (create-hero "Anduin Wrynn"),
                :secrets [(create-secret "Snake Trap")]}]
              :player-id-in-turn
              "p2")
            {:player-id-in-turn "p2",
             :players
               {"p1" {:id "p1",
                      :deck [],
                      :hand [],
                      :minions [{:attacks-performed-this-turn 0,
                                 :entity-type "minion",
                                 :attack 1,
                                 :original-attack 1,
                                 :health 1,
                                 :original-health 1,
                                 :max-health 1,
                                 :states {},
                                 :name "Imp",
                                 :id "m1",
                                 :position 0,
                                 :owner-id "p1",
                                 :frozen false,
                                 :play-order 1}],
                      :secrets [],
                      :cards-overdrawn 0,
                      :mana 1,
                      :max-mana 1,
                      :hero {:name "Jaina Proudmoore",
                             :entity-type :hero,
                             :hero-power "Fireblast",
                             :times-hero-power-used 0,
                             :health 30,
                             :max-health 30,
                             :id "h1",
                             :frozen false}},
                "p2" {:id "p2",
                      :deck [],
                      :hand [],
                      :minions [],
                      :secrets
                        [{:entity-type "secret",
                          :name "Snake Trap",
                          :id "1",
                          :states {:effect {:on-attack
                                              [{:effect-source "Snake Trap",
                                                :effect-key :trap-triggered}]}},
                          :owner-id "p2",
                          :play-order 2}],
                      :cards-overdrawn 0,
                      :mana 5,
                      :max-mana 10,
                      :hero {:name "Anduin Wrynn",
                             :id "h2",
                             :entity-type :hero,
                             :hero-power "Lesser Heal",
                             :times-hero-power-used 0,
                             :health 30,
                             :max-health 30,
                             :frozen false}}},
             :counter-id 2,
             :counter-play-order 3,
             :minion-ids-summoned-this-turn [],
             :spells-cast-this-turn [],
             :seed 314159265})
       ; Test setting the seed
       (is= (:seed (create-game [] :seed 123)) 123))}
  ([data & kvs]
   ; TODO this could be made a LOT nicer if anyone spent 4 minutes... Anyone?
   {:pre [(every? (fn [s] (vector? (get s :minions []))) data)
          (every? (fn [s] (map? s)) data)
          (every? (fn [s]
                    (or (seq? (get s :hand [])) (vector? (get s :hand []))))
                  data)]}
   (let [state
           (as->
             (create-empty-state
               (map (fn [player-data]
                      (cond (nil? (:hero player-data)) (create-hero
                                                         "Jaina Proudmoore")
                            (string? (:hero player-data)) (create-hero
                                                            (:hero player-data))
                            :else (:hero player-data)))
                 data))
             $
             ; Add minions to the state
             (reduce (fn [state {player-id :player-id, minions :minions}]
                       (reduce (fn [state [index minion]]
                                 (add-minion-to-board state
                                                      {:player-id player-id,
                                                       :minion minion,
                                                       :position index}))
                         state
                         (map-indexed (fn [index minion] [index minion])
                                      minions)))
               $
               (map-indexed (fn [index player-data]
                              {:player-id (str "p" (inc index)),
                               :minions (:minions player-data)})
                            data))
             ; Add cards to hand
             (reduce (fn [state {player-id :player-id, hand :hand}]
                       ;(assoc-in state [:players player-id :hand] hand))
                       (reduce (fn [state card]
                                 (add-card-to-hand state player-id card))
                         state
                         hand))
               $
               (map-indexed (fn [index player-data]
                              {:player-id (str "p" (inc index)),
                               :hand (get player-data :hand [])})
                            data))
             ; Add secrets and mana
             (reduce (fn [state
                          {player-id :player-id,
                           secrets :secrets,
                           mana :mana,
                           max-mana :max-mana}]
                       (-> (reduce
                             (fn [state secret]
                               (add-secret-to-board state player-id secret))
                             state
                             secrets)
                           (assoc-in [:players player-id :mana] mana)
                           (assoc-in [:players player-id :max-mana] max-mana)))
               $
               (map-indexed (fn [index player-data]
                              {:player-id (str "p" (inc index)),
                               :secrets (get player-data :secrets []),
                               :mana (get player-data :mana 10),
                               :max-mana (get player-data :max-mana 10)})
                            data))
             ; Add cards to deck
             (reduce (fn [state {player-id :player-id, deck :deck}]
                       (assoc-in state [:players player-id :deck] deck))
               $
               (map-indexed (fn [index player-data]
                              {:player-id (str "p" (inc index)),
                               :deck (get player-data :deck [])})
                            data)))]
     ; TODO unneeded?
     (as-> (assoc state :minion-ids-summoned-this-turn []) $
       (assoc $ :spells-cast-this-turn [])
       (if (empty? kvs) $ (apply assoc $ kvs)))))
  ([] (create-game [])))

(defn get-minion
  "Returns the minion with the given id."
  {:test (fn []
           (is= (-> (create-game [{:minions [(create-minion "Imp" :id "i")]}])
                    (get-minion "i")
                    (:name))
                "Imp"))}
  [state id]
  (->> (get-minions state)
       (filter (fn [m] (= (:id m) id)))
       (first)))

(defn get-heroes
  "Get heroes in a game"
  {:test (fn []
           (is= (->> (create-game)
                     (get-heroes)
                     (map :name))
                ["Jaina Proudmoore" "Jaina Proudmoore"]))}
  [state]
  (->> (:players state)
       (vals)
       (map :hero)))

(defn replace-minion
  "Replaces a minion with the same id as the given new-minion."
  {:test (fn []
           (is=
             (-> (create-game [{:minions [(create-minion "Imp" :id "minion")]}])
                 (replace-minion (create-minion "War Golem" :id "minion"))
                 (get-minion "minion")
                 (:name))
             "War Golem"))}
  [state new-minion]
  (let [owner-id (or (:owner-id new-minion)
                     (:owner-id (get-minion state (:id new-minion))))]
    (update-in state
               [:players owner-id :minions]
               (fn [minions]
                 (map (fn [m] (if (= (:id m) (:id new-minion)) new-minion m))
                   minions)))))

(defn update-minion
  "Updates the value of the given key for the minion with the given id. If function-or-value is a value it will be the
   new value, else if it is a function it will be applied on the existing value to produce the new value."
  {:test (fn []
           (is= (-> (create-game [{:minions [(create-minion "Imp" :id "i")]}])
                    (update-minion "i" :health inc)
                    (get-minion "i")
                    (get :health))
                2)
           (is= (-> (create-game [{:minions [(create-minion "Imp" :id "i")]}])
                    (update-minion "i" :attack 2)
                    (get-minion "i")
                    (get :attack))
                2))}
  [state id key function-or-value]
  (let [minion (get-minion state id)]
    (replace-minion state
                    (if (function? function-or-value)
                      (update minion key function-or-value)
                      (assoc minion key function-or-value)))))

; TODO should this throw exception for nonexistant entity ids?
(defn get-entity
  "Returns the character with the given id from the state."
  {:test (fn []
           (is= (-> (create-game
                      [{:hero (create-hero "Jaina Proudmoore" :id "h1")}])
                    (get-entity "h1")
                    (:name))
                "Jaina Proudmoore")
           (is= (-> (create-game [{:minions [(create-minion "Imp" :id "i")]}])
                    (get-entity "i")
                    (:name))
                "Imp")
           ; Get entities from hand
           (is= (-> (create-game
                      [{:hand [(create-card "Big Game Hunter" :id "bgh1")]}])
                    (get-entity "bgh1")
                    (:name))
                "Big Game Hunter"))}
  [state id]
  (->> (concat (get-minions state)
               (get-heroes state)
               (get-secrets state)
               (get-hand state "p1")
               (get-hand state "p2"))
       (filter (fn [c] (= (:id c) id)))
       (first)))

(defn remove-secret
  "Removes a secret with the given id from the state."
  {:test (fn []
           (is= (-> (create-game [{:secrets
                                     [(create-secret "Snake Trap" :id "i")]}])
                    (remove-secret "i")
                    (get-in [:players "p1" :secrets]))
                []))}
  [state id]
  {:pre [(map? state) (string? id)]}
  (let [owner-id (:owner-id (get-entity state id))]
    (update-in state
               [:players owner-id :secrets]
               (fn [secrets] (remove (fn [m] (= (:id m) id)) secrets)))))

(defn recalculate-positions
  [state player-id]
  (update-in state
             [:players player-id :minions]
             (fn [minions]
               (map-indexed (fn [index minion] (assoc minion :position index))
                            (sort (fn [m1 m2] (< (:position m1) (:position m2)))
                                  minions)))))

(defn remove-minion
  "Removes a minion with the given id from the state."
  {:test (fn []
           (is= (-> (create-game [{:minions [(create-minion "Imp" :id "i")]}])
                    (remove-minion "i")
                    (get-minions))
                []))}
  [state id]
  (let [owner-id (:owner-id (get-minion state id))]
    (-> (update-in state
                   [:players owner-id :minions]
                   (fn [minions] (remove (fn [m] (= (:id m) id)) minions)))
        (recalculate-positions owner-id))))

(defn remove-minions
  "Removes the minions with the given ids from the state."
  {:test (fn []
           (is=
             (as-> (create-game [{:minions [(create-minion "Imp" :id "i1")
                                            (create-minion "Imp" :id "i2")]}
                                 {:minions [(create-minion "Imp" :id "i3")
                                            (create-minion "Imp" :id "i4")]}]) $
               (remove-minions $ "i1" "i4")
               (get-minions $)
               (map :id $))
             ["i2" "i3"]))}
  [state & ids]
  (reduce remove-minion state ids))

(defn get-deck
  "Returns the deck of the given player"
  [state player-id]
  (get-in state [:players player-id :deck]))

(defn get-hand
  "Returns the hand of the given player"
  [state player-id]
  (get-in state [:players player-id :hand]))

(defn is-player?
  "Check whether an entity is a player"
  {:test (fn []
           (is (-> (create-game)
                   (is-player? "p1")))
           (is-not (-> (create-game)
                       (is-player? "k1"))))}
  [state player-id]
  (if (> (count (filter #(= %1 player-id) (keys (:players state)))) 0)
    true
    false))

(defn add-card-to-hand
  "Add card to hand"
  {:test (fn []
           ; Test ID generation
           (is= (as-> (create-game) $
                  (add-card-to-hand $ "p1" (create-card "Defender"))
                  (get-hand $ "p1")
                  (filter #(= (:name %1) "Defender") $)
                  (first $)
                  (:id $))
                "1")
           (is= (as-> (create-game) $
                  (add-card-to-hand $ "p1" (create-card "Imp"))
                  (get-hand $ "p1")
                  (filter #(= (:name %1) "Imp") $)
                  (count $))
                1))}
  [state player-id card]
  {:pre [(is-player? state player-id) (string? player-id) (map? state)
         (map? card)]}
  ; Check if an ID was given, otherwise, generate one
  (let [[state card] (if (contains? card :id)
                       [state card]
                       (let [[state id] (generate-id state)]
                         [state (assoc card :id (str id))]))]
    (update-in state [:players player-id :hand] #(conj %1 card))))



(defn add-card-to-deck
  "Add cards to a deck with the given cards."
  {:test (fn []
           (is= (-> (add-card-to-deck (create-game) "p1" "Imp")
                    (get-in [:players "p1" :deck 0 :id]))
                "1")
           ; If no cards are supplied, an deck of 30 cards will be generated.
           (is= (-> (add-card-to-deck (create-game) "p1" "Imp")
                    (:players)
                    (get "p1")
                    (:deck)
                    (count))
                1)
           ; Adding a card to the deck should give it an ID
           (is= (-> (-> (add-card-to-deck (create-game) "p1" "Imp")
                        (:players)
                        (get "p1")
                        (:deck)
                        (first)
                        (:id)))
                "1")
           (is= (-> (-> (add-card-to-deck (create-game) "p1" "Imp")
                        (add-card-to-deck "p2" "Imp")
                        (:players)
                        (get "p2")
                        (:deck)
                        (first)
                        (:id)))
                "2"))}
  [state player-id card-name]
  (let [[state card-id] (generate-id state)]
    (->> (vec (conj (get-in state [:players player-id :deck])
               (create-card card-name :id (str card-id))))
         (assoc (get-in state [:players player-id]) :deck)
         (assoc (get state :players) player-id)
         (assoc state :players))))


(defn get-secrets
  "Returns the secrets on the board for the given player-id or for both players."
  {:test (fn []
           (is= (-> (create-game)
                    (get-secrets "p1"))
                [])
           (is= (-> (create-game [{} {:secrets [(create-card "Snake Trap")]}])
                    (get-secrets)
                    (count))
                1)
           (is= (-> (create-game [{} {:secrets [(create-card "Snake Trap")]}])
                    (get-secrets "p1")
                    (count))
                0)
           (is= (-> (create-game [{} {:secrets [(create-card "Snake Trap")]}])
                    (get-secrets "p2")
                    (count))
                1))}
  ([state player-id]
   {:pre [(map? state) (string? player-id)]}
   (:secrets (get-player state player-id)))
  ([state]
   {:pre [(map? state)]}
   (->> (:players state)
        (vals)
        (map :secrets)
        (apply concat))))
